//（动态规划）：用"状态转移"思想，把问题分解成子问题，通过填表的方式逐步求解
// 动态规划（DP）- 循环+状态转移
//把大问题分解成小问题，用表格记录中间结果，避免重复计算

//而之前的DFS回溯 - 递归+剪枝
//尝试所有可能的选择，遇到不满足条件时提前终止 
// 深度优先探索所有路径
//剪枝：if (currentCapacity >= w[i]) 避免无效选择
#include <iostream>
using namespace std;

int v[301], w[301], dp[301][301];  // 数组在主函数外定义，元素自动初始化为0

int main() {
    int m, n;
    cin >> m >> n;  // m是背包容量，n是物品数量
    
    // 输入每个物品的体积和价值
    for (int i = 1; i <= n; i++) {
        cin >> w[i] >> v[i];
    }
    
    // 动态规划填表
    for (int i = 1; i <= n; i++) {  // 遍历每个物品
        for (int j = 1; j <= m; j++) {  // 遍历每个容量
            if (j < w[i]) {  // 当前容量放不下第i个物品
                dp[i][j] = dp[i-1][j];  // 继承上一层状态
            } else {  // 可以选择放或不放
                dp[i][j] = max(dp[i-1][j], dp[i-1][j-w[i]] + v[i]);
            }
        }
    }
    
    cout << dp[n][m] << endl;  // 输出最终结果
    return 0;
}

