#include <iostream>
#include <cstring> // 需要引入这个头文件来使用 strlen
using namespace std;

const int N = 1e6 + 9;
char s[N];

int main()
{
    // 1. 优化输入输出效率，这对于大数据量的题目（如1e6）非常有用
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);

    // 2. cin >> s+1;
    // 这一步很巧妙。通常数组从下标0开始存，但这里 s+1 表示从数组的第2个位置（下标1）开始存入字符串。
    // 这样做的目的是为了让下标 i 直接对应第 i 个字符，方便后续处理，符合我们的一般计数习惯（第1个字符下标就是1）。
    cin >> s + 1;

    // 3. int n = strlen(s + 1);
    // 计算字符串的长度。同样因为数据是从 s[1] 开始存的，所以计算长度也要从 s+1 开始算。
    // n 得到的就是字符串中实际字符的个数。
    int n = strlen(s + 1);

    // 4. int l = 1, r = n;
    // 初始化对撞指针：
    // l (left) 指向字符串的第一个字符（下标1）。
    // r (right) 指向字符串的最后一个字符（下标n）。
    int l = 1, r = n;

    // 5. bool ans = true;
    // 先假设这是一个回文串。如果后续发现不匹配的情况，再将其修改为 false。
    bool ans = true;

    // 6. while(l < r && ans)
    // 循环条件：
    // l < r：当左指针还在右指针左边时继续判断。如果 l >= r，说明所有对应位置的字符都比对完了，或者只剩中间一个字符了。
    // && ans：如果 ans 已经是 false（已经确定不是回文了），就提前结束循环，不再做无用的运算。
    while(l < r && ans)
    {
        // 7. if(s[l] != s[r])
        // 核心判断：检查当前左指针对应的字符 和 右指针对应的字符 是否不相等。
        if(s[l] != s[r])
            ans = false; // 如果不相等，说明不是回文串，标记为 false。
        
        // 8. l++, r--;
        // 无论这一轮是否相等，指针都要向中间移动一步。
        // 左指针往右走一格，右指针往左走一格，准备判断下一对字符。
        l++;
        r--;
    }

    // 9. cout << (ans ? "Y" : "N");
    // 使用三元运算符输出结果：
    // 如果 ans 是 true，输出 "Y"（是回文）。
    // 如果 ans 是 false，输出 "N"（不是回文）。
    cout << (ans ? "Y" : "N");

    return 0;
}

